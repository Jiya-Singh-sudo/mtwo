import { Injectable } from '@nestjs/common';
import { DatabaseService } from '../database/database.service';
import * as crypto from 'crypto';

export interface ActivityLogInput {
  message: string;
  module: string;
  action: string;
  referenceId?: string | null;
  performedBy?: string | null;
  ipAddress?: string | null;
}

@Injectable()
export class ActivityLogService {
  constructor(private readonly db: DatabaseService) {}

  private sha256(input: string) {
    return crypto.createHash('sha256').update(input).digest('hex');
  }

  /**
   * Insert a new activity log entry
   * NOTE:
   * - ID is generated by PostgreSQL (UUID)
   * - No deletes, ever
   * - Immutable audit record
   */
  async log(input: ActivityLogInput, client?: any): Promise<void> {
  // 1️⃣ Get previous hash
  const prevRes = await client.query(`
    SELECT hash
    FROM t_activity_log
    WHERE hash IS NOT NULL
    ORDER BY inserted_at DESC
    LIMIT 1
  `);

  const prevHash: string | null = prevRes.rows[0]?.hash ?? null;

  // 2️⃣ Fixed timestamp (must be stable)
  const insertedAt = new Date().toISOString();

  // 3️⃣ Build deterministic hash input
  const raw = [
    input.message,
    input.module,
    input.action,
    input.referenceId ?? '',
    input.performedBy ?? '',
    insertedAt,
    prevHash ?? '',
  ].join('|');

  const hash = this.sha256(raw);

  // 4️⃣ Insert log with hash chain
  const sql = `
    INSERT INTO t_activity_log (
      activity_id,
      message,
      module,
      action,
      reference_id,
      performed_by,
      is_active,
      inserted_at,
      inserted_by,
      inserted_ip,
      prev_hash,
      hash
    )
    VALUES (
      gen_random_uuid()::text,
      $1, $2, $3, $4, $5,
      true,
      $6,
      $5,
      $7,
      $8,
      $9
    )
  `;

  await client.query(sql, [
    input.message,
    input.module,
    input.action,
    input.referenceId ?? null,
    input.performedBy ?? null,
    insertedAt,
    input.ipAddress ?? null,
    prevHash,
    hash,
  ]);
}

async verifyChain() {
  const res = await this.db.query(`
    SELECT
      activity_id,
      message,
      module,
      action,
      reference_id,
      performed_by,
      inserted_at,
      prev_hash,
      hash
    FROM t_activity_log
    WHERE hash IS NOT NULL
    ORDER BY inserted_at ASC
  `);

  const rows = res.rows;

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];

    const expectedPrev =
      i === 0 ? null : rows[i - 1].hash;

    if (row.prev_hash !== expectedPrev) {
      return {
        valid: false,
        brokenAt: row.activity_id,
        reason: 'prev_hash mismatch',
      };
    }

    const raw = [
      row.message,
      row.module,
      row.action,
      row.reference_id ?? '',
      row.performed_by ?? '',
      new Date(row.inserted_at).toISOString(),
      row.prev_hash ?? '',
    ].join('|');

    const recalculated = this.sha256(raw);

    if (recalculated !== row.hash) {
      return {
        valid: false,
        brokenAt: row.activity_id,
        reason: 'hash mismatch',
      };
    }
  }

  return {
    valid: true,
    total: rows.length,
  };
}

  /**
   * Fetch recent activity logs (dashboard / admin view)
   */
  async getRecentActivity(limit = 5) {
    const sql = `
      SELECT
        activity_id,
        message,
        module,
        action,
        reference_id,
        performed_by,
        inserted_at
      FROM t_activity_log
      WHERE is_active = true
      ORDER BY inserted_at DESC
      LIMIT $1
    `;

    const result = await this.db.query(sql, [limit]);
    return result.rows;
  }
  async search(params: {
    module?: string;
    action?: string;
    performedBy?: string;
    from?: string;
    to?: string;
    page?: number;
    limit?: number;
  }) {
    const {
      module,
      action,
      performedBy,
      from,
      to,
      page = 1,
      limit = 20,
    } = params;

    const safeLimit = Math.min(limit, 100);
    const offset = (page - 1) * safeLimit;

    const conditions: string[] = ['is_active = true'];
    const values: any[] = [];

    if (module) {
      values.push(module);
      conditions.push(`module = $${values.length}`);
    }

    if (action) {
      values.push(action);
      conditions.push(`action = $${values.length}`);
    }

    if (performedBy) {
      values.push(performedBy);
      conditions.push(`performed_by = $${values.length}`);
    }

    if (from) {
      values.push(from);
      conditions.push(`inserted_at >= $${values.length}`);
    }

    if (to) {
      values.push(to);
      conditions.push(`inserted_at <= $${values.length}`);
    }

    const whereClause = conditions.length
      ? `WHERE ${conditions.join(' AND ')}`
      : '';

    const dataSql = `
      SELECT
        activity_id,
        message,
        module,
        action,
        reference_id,
        performed_by,
        inserted_at,
        inserted_ip
      FROM t_activity_log
      ${whereClause}
      ORDER BY inserted_at DESC
      LIMIT ${safeLimit} OFFSET ${offset}
    `;

    const countSql = `
      SELECT COUNT(*)::int AS total
      FROM t_activity_log
      ${whereClause}
    `;

    const [dataRes, countRes] = await Promise.all([
      this.db.query(dataSql, values),
      this.db.query(countSql, values),
    ]);

    return {
      data: dataRes.rows,
      meta: {
        page,
        limit: safeLimit,
        total: countRes.rows[0].total,
      },
    };
  }
  // async findRecent(limit: number) {
  //   return this.db.query(`
  //     SELECT 
  //       id,
  //       action,
  //       entity,
  //       description,
  //       created_at
  //     FROM activity_logs
  //     ORDER BY created_at DESC
  //     LIMIT $1
  //   `, [limit]);
  // }
}
