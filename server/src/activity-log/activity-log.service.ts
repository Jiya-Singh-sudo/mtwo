import { Injectable } from '@nestjs/common';
import { DatabaseService } from '../database/database.service';

export interface ActivityLogInput {
  message: string;
  module: string;
  action: string;
  referenceId?: string | null;
  performedBy?: string | null;
  ipAddress?: string | null;
}

@Injectable()
export class ActivityLogService {
  constructor(private readonly db: DatabaseService) {}

  /**
   * Insert a new activity log entry
   * NOTE:
   * - ID is generated by PostgreSQL (UUID)
   * - No deletes, ever
   * - Immutable audit record
   */
  async log(input: ActivityLogInput): Promise<void> {
    const sql = `
      INSERT INTO t_activity_log (
        activity_id,
        message,
        module,
        action,
        reference_id,
        performed_by,
        is_active,
        inserted_at,
        inserted_by,
        inserted_ip
      )
      VALUES (
        gen_random_uuid()::text,
        $1, $2, $3, $4, $5,
        true,
        NOW(),
        $5,
        $6
      )
    `;

    await this.db.query(sql, [
      input.message,
      input.module,
      input.action,
      input.referenceId ?? null,
      input.performedBy ?? null,
      input.ipAddress ?? null,
    ]);
  }

  /**
   * Fetch recent activity logs (dashboard / admin view)
   */
  async getRecentActivity(limit = 5) {
    const sql = `
      SELECT
        activity_id,
        message,
        module,
        action,
        reference_id,
        performed_by,
        inserted_at
      FROM t_activity_log
      WHERE is_active = true
      ORDER BY inserted_at DESC
      LIMIT $1
    `;

    const result = await this.db.query(sql, [limit]);
    return result.rows;
  }
  async search(params: {
    module?: string;
    action?: string;
    performedBy?: string;
    from?: string;
    to?: string;
    page?: number;
    limit?: number;
  }) {
    const {
      module,
      action,
      performedBy,
      from,
      to,
      page = 1,
      limit = 20,
    } = params;

    const safeLimit = Math.min(limit, 100);
    const offset = (page - 1) * safeLimit;

    const conditions: string[] = ['is_active = true'];
    const values: any[] = [];

    if (module) {
      values.push(module);
      conditions.push(`module = $${values.length}`);
    }

    if (action) {
      values.push(action);
      conditions.push(`action = $${values.length}`);
    }

    if (performedBy) {
      values.push(performedBy);
      conditions.push(`performed_by = $${values.length}`);
    }

    if (from) {
      values.push(from);
      conditions.push(`inserted_at >= $${values.length}`);
    }

    if (to) {
      values.push(to);
      conditions.push(`inserted_at <= $${values.length}`);
    }

    const whereClause = conditions.length
      ? `WHERE ${conditions.join(' AND ')}`
      : '';

    const dataSql = `
      SELECT
        activity_id,
        message,
        module,
        action,
        reference_id,
        performed_by,
        inserted_at,
        inserted_ip
      FROM t_activity_log
      ${whereClause}
      ORDER BY inserted_at DESC
      LIMIT ${safeLimit} OFFSET ${offset}
    `;

    const countSql = `
      SELECT COUNT(*)::int AS total
      FROM t_activity_log
      ${whereClause}
    `;

    const [dataRes, countRes] = await Promise.all([
      this.db.query(dataSql, values),
      this.db.query(countSql, values),
    ]);

    return {
      data: dataRes.rows,
      meta: {
        page,
        limit: safeLimit,
        total: countRes.rows[0].total,
      },
    };
  }
}
